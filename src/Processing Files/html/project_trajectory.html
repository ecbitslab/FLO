
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><title>project_trajectory</title><meta name="generator" content="MATLAB 7.10"><meta name="date" content="2011-07-15"><meta name="m-file" content="project_trajectory"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Summary of function project_trajectory:</a></li><li><a href="#4">Input and Output specifications:</a></li><li><a href="#5">Create candidate search area.</a></li><li><a href="#6">Find candidates and project track.</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> track = project_trajectory(frame,tcoords,ptrack,dist,bd_max,sfactor,debug)
</pre><h2>Summary of function project_trajectory:<a name="3"></a></h2><pre>Function to determine which particles are a part of the same track as
the given point of interest.  Uses a recursive algorithm to predict the
locations of particles in the track.  When no other candidates are
found, the track that was found with the greatest number of points is
returned.</pre><h2>Input and Output specifications:<a name="4"></a></h2><p>INPUT:</p><p>- frame:    Image matrix for the current frame.  Included for debugging             purposes.</p><p>- tcoords:  Coordinates of particle centroids in frame. Contains x             coordinates, y coordinates, brightnesses, square of radius of             gyration, distance from source, and whether or not particle             is active.</p><p>- ptrack:   Matrix of bubble indices previously found to be a part of the             track.  This will be added to recursively to construct the             entire track.</p><p>- dist:     Distance between the point of interest and the candidate.</p><p>- bd_max:   User defined value based on the histogram of radius of             gyration data - determines the size of the search area when             searching for candidates.</p><p>- sfactor:  User defined search factor.  Multiplied by bd_max to             increase the search area when searching for candidates.</p><p>- debug:    Flag to indicate whether or not the track finding process             should be shown for debugging or thresholding purposes.  Can             be 0, 1, or 2. 0 = no display, 1 = initial bubble in track             and final track displayed, 2 = entire search process             displayed.</p><p>OUTPUT:</p><p>- track:    Matrix containing the indices of the points in the track.</p><p>Written by Michael Meaden - Elmhurst College BITS Lab, 06/22/2011.</p><h2>Create candidate search area.<a name="5"></a></h2><pre class="codeinput"><span class="comment">% Extract x and y coordinates for last found point in the track.</span>
poi = ptrack(length(ptrack));
poix = tcoords(poi,1);
poiy = tcoords(poi,2);

<span class="comment">% Calculate angle between last two points of the track.</span>
velAngle = calcAngle(tcoords,ptrack(length(ptrack)-1),ptrack(length(ptrack)),0);

<span class="comment">% Calculate estimated x and y coordinates of the next bubble.</span>
xest = poix + dist*cos(velAngle);
yest = poiy + dist*sin(velAngle);

<span class="comment">% Calculate the approximate search area for the next point in the track.</span>
bxMin = xest - sfactor*bd_max;
bxMax = xest + sfactor*bd_max;
byMin = yest - sfactor*bd_max;
byMax = yest + sfactor*bd_max;
</pre><h2>Find candidates and project track.<a name="6"></a></h2><pre class="codeinput"><span class="comment">% Find all bubbles in approximate search area.</span>
candidates = find(bxMin&lt;tcoords(:,1)&lt;bxMax &amp; byMin&lt;tcoords(:,2)&lt;byMax &amp; tcoords(:,6)==1);

<span class="comment">% Remove any bubbles that are already in ptrack and being considered</span>
<span class="comment">% candidates.</span>
<span class="keyword">for</span> ii = 1:1:size(ptrack,2)
    candidates = candidates(candidates~=ptrack(ii));
<span class="keyword">end</span>

<span class="comment">% Debug plot - displays ptrack, search area, and potential candidates</span>
<span class="keyword">if</span> debug == 2
    clear <span class="string">gcf</span>; imshow(frame); hold <span class="string">on</span>;
    plot(tcoords(ptrack,1),tcoords(ptrack,2),<span class="string">'or'</span>); pause(0.2);
    debugAngles = 0:((2*pi)/40):2*pi;
    DBCirclex = xest + (sfactor*bd_max)*cos(debugAngles);
    DBCircley = yest + (sfactor*bd_max)*sin(debugAngles);
    plot(DBCirclex,DBCircley,<span class="string">'-b'</span>); pause(0.2);
    plot(tcoords(candidates,1),tcoords(candidates,2),<span class="string">'og'</span>);
<span class="keyword">end</span>

<span class="comment">% Reset found flag to 0.</span>
found = 0;

<span class="comment">% If there are no more bubbles found in the search area, return the</span>
<span class="comment">% previously found track.</span>
<span class="keyword">if</span> size(candidates,1) == 0
    track = ptrack;
<span class="comment">% If potential candidates were found, explore all possible tracks by</span>
<span class="comment">% calling project_trajectory function.</span>
<span class="keyword">else</span>
    <span class="comment">% Loop over candidates.</span>
    <span class="keyword">for</span> ii = 1:1:size(candidates,1)
        <span class="comment">% When a potential candidate is found to be within the search</span>
        <span class="comment">% window, set the found flag and continue projection.</span>
        canx = tcoords(candidates(ii),1);
        cany = tcoords(candidates(ii),2);
        canDist = sqrt((xest-canx)^2+(yest-cany)^2);
        <span class="keyword">if</span> (found == 0) &amp;&amp; (canDist&lt;=(sfactor*bd_max))
            found = 1;
            modDist = calcDistance(tcoords,candidates(ii),poi);
            modPtrack = [ptrack candidates(ii)];
            track = project_trajectory(frame,tcoords,modPtrack,modDist,bd_max,sfactor,debug);
        <span class="comment">% If multiple tracks are found, pick the one with the most support.</span>
        <span class="keyword">elseif</span> (found == 1) &amp;&amp; (canDist&lt;=(sfactor*bd_max))
            modDist = calcDistance(tcoords,candidates(ii),poi);
            modPtrack = [ptrack candidates(ii)];
            compTrack = project_trajectory(frame,tcoords,modPtrack,modDist,bd_max,sfactor,debug);
            <span class="keyword">if</span> size(track,1) &lt; size(compTrack,1)
                track = compTrack;
            <span class="keyword">end</span>
        <span class="comment">% If no candidates are found within the search area, return ptrack.</span>
        <span class="keyword">elseif</span> (found == 0) &amp;&amp; (ii == size(candidates,1))
            track = ptrack;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.10<br></p></div><!--
##### SOURCE BEGIN #####
function track = project_trajectory(frame,tcoords,ptrack,dist,bd_max,sfactor,debug)

%% Summary of function project_trajectory:
%  Function to determine which particles are a part of the same track as
%  the given point of interest.  Uses a recursive algorithm to predict the
%  locations of particles in the track.  When no other candidates are
%  found, the track that was found with the greatest number of points is
%  returned.

%% Input and Output specifications:
% INPUT:
%
% - frame:    Image matrix for the current frame.  Included for debugging
%             purposes.
%
% - tcoords:  Coordinates of particle centroids in frame. Contains x
%             coordinates, y coordinates, brightnesses, square of radius of
%             gyration, distance from source, and whether or not particle
%             is active.
%
% - ptrack:   Matrix of bubble indices previously found to be a part of the
%             track.  This will be added to recursively to construct the
%             entire track.
%
% - dist:     Distance between the point of interest and the candidate.
%
% - bd_max:   User defined value based on the histogram of radius of
%             gyration data - determines the size of the search area when
%             searching for candidates.
%
% - sfactor:  User defined search factor.  Multiplied by bd_max to
%             increase the search area when searching for candidates.
%
% - debug:    Flag to indicate whether or not the track finding process
%             should be shown for debugging or thresholding purposes.  Can 
%             be 0, 1, or 2. 0 = no display, 1 = initial bubble in track
%             and final track displayed, 2 = entire search process
%             displayed.
%
% OUTPUT:
%
% - track:    Matrix containing the indices of the points in the track.
%
% Written by Michael Meaden - Elmhurst College BITS Lab, 06/22/2011.

%% Create candidate search area.

% Extract x and y coordinates for last found point in the track.
poi = ptrack(length(ptrack));
poix = tcoords(poi,1);
poiy = tcoords(poi,2);

% Calculate angle between last two points of the track.
velAngle = calcAngle(tcoords,ptrack(length(ptrack)-1),ptrack(length(ptrack)),0);

% Calculate estimated x and y coordinates of the next bubble.
xest = poix + dist*cos(velAngle);
yest = poiy + dist*sin(velAngle);

% Calculate the approximate search area for the next point in the track.
bxMin = xest - sfactor*bd_max;
bxMax = xest + sfactor*bd_max;
byMin = yest - sfactor*bd_max;
byMax = yest + sfactor*bd_max;

%% Find candidates and project track.

% Find all bubbles in approximate search area.
candidates = find(bxMin<tcoords(:,1)<bxMax & byMin<tcoords(:,2)<byMax & tcoords(:,6)==1);

% Remove any bubbles that are already in ptrack and being considered
% candidates.
for ii = 1:1:size(ptrack,2)
    candidates = candidates(candidates~=ptrack(ii));
end

% Debug plot - displays ptrack, search area, and potential candidates
if debug == 2
    clear gcf; imshow(frame); hold on;    
    plot(tcoords(ptrack,1),tcoords(ptrack,2),'or'); pause(0.2);
    debugAngles = 0:((2*pi)/40):2*pi;
    DBCirclex = xest + (sfactor*bd_max)*cos(debugAngles);
    DBCircley = yest + (sfactor*bd_max)*sin(debugAngles);
    plot(DBCirclex,DBCircley,'-b'); pause(0.2);
    plot(tcoords(candidates,1),tcoords(candidates,2),'og');    
end

% Reset found flag to 0.
found = 0;

% If there are no more bubbles found in the search area, return the
% previously found track.
if size(candidates,1) == 0
    track = ptrack;
% If potential candidates were found, explore all possible tracks by
% calling project_trajectory function.
else
    % Loop over candidates.
    for ii = 1:1:size(candidates,1)
        % When a potential candidate is found to be within the search
        % window, set the found flag and continue projection.
        canx = tcoords(candidates(ii),1);
        cany = tcoords(candidates(ii),2);
        canDist = sqrt((xest-canx)^2+(yest-cany)^2);
        if (found == 0) && (canDist<=(sfactor*bd_max))
            found = 1;
            modDist = calcDistance(tcoords,candidates(ii),poi);
            modPtrack = [ptrack candidates(ii)];
            track = project_trajectory(frame,tcoords,modPtrack,modDist,bd_max,sfactor,debug);
        % If multiple tracks are found, pick the one with the most support.
        elseif (found == 1) && (canDist<=(sfactor*bd_max))
            modDist = calcDistance(tcoords,candidates(ii),poi);
            modPtrack = [ptrack candidates(ii)];
            compTrack = project_trajectory(frame,tcoords,modPtrack,modDist,bd_max,sfactor,debug);
            if size(track,1) < size(compTrack,1)
                track = compTrack;
            end
        % If no candidates are found within the search area, return ptrack.    
        elseif (found == 0) && (ii == size(candidates,1))
            track = ptrack;
        end
    end
end












##### SOURCE END #####
--></body></html>